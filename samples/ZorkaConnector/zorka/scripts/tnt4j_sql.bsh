/*
 * Copyright 2014-2018 JKOOL, LLC.
 *
 * This file is part of TNT4J-Streams-Zorka.
 *
 * TNT4J-Streams-Zorka is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * TNT4J-Streams-Zorka is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with TNT4J-Streams-Zorka.  If not, see <http://www.gnu.org/licenses/>.
 */

zorka.require("sql.bsh", "tnt4j_comm.bsh");

// This script gets TNT4J Correlation IDs

__tnt4j_sql() {

    _trace = true;

    spy.add(
        spy.instrument("SQL_TNT4J_STREAMS_TRACKER")
            .onEnter(
                    spy.fetchArg("THIS", 0), spy.fetchArg("SQL", 1),
                    tracer.isInTrace("HTTP") ? null : tracer.begin("SQL"),
                    tracer.isInTrace("HTTP") ? null : tracer.formatAttr("MARKER", "SQL"),
                    __tnt4j.attrAppl("SQL"),
                    __tnt4j.attrCorrelator(),
                    spy.zorkaLog("DEBUG", "SQL", "########################execute ############# ${APPL} ####### ${JK_CORR_RID} "),
                    tracer.formatAttr("EVENT_TYPE", "SEND"),
                    tracer.isInTrace("HTTP") ? null : tracer.flags(tracer.SUBMIT_TRACE),
                    spy.format("DB", "${THIS.connection.database}"),
                    _trace
                        ? spy.subchain(
                            tracer.isInTrace("HTTP") ? null : tracer.begin("SQL"),
                            tracer.attr("SQL", "SQL"),
                            __tnt4j.getThread(),
                            tracer.attr("DB", "DB"))
                        : null
            )
            .onError(
                    spy.fetchError("ERR"),
                    _trace ? tracer.flags(tracer.SUBMIT_TRACE) : null, 
                    sql._error_chain
            )
            .onSubmit(spy.strTime("TIME"), sql._slow_chain, sql._stats_chain)
            .include(
                    spy.byMethod(spy.AC_PUBLIC, "com.mysql.jdbc.StatementImpl", "execut*", null, "String")
            )
    );

    spy.add(
        spy.instrument("SQL_TNT4J_STREAMS_TRACKER2")
            .onEnter(
                    spy.fetchArg("THIS", 0),
                    tracer.isInTrace("HTTP") ? null : tracer.begin("SQL"),
                    __tnt4j.attrAppl("SQL"),
                    __tnt4j.attrCorrelator(),
                    tracer.isInTrace("HTTP") ? null : tracer.formatAttr("MARKER", "SQL"),
                    tracer.formatAttr("EVENT_TYPE", "SEND"),

                    tracer.isInTrace("HTTP") ? null : tracer.flags(tracer.SUBMIT_TRACE),
                    spy.format("SQL", "${THIS.originalSql|THIS.SQLText|THIS.sqlObject.originalSql}"),
                    spy.format("DB", "${THIS.connection.database|THIS.lcc.dbname|THIS.statement.t4Connection.database}:${THIS.statement.t4Connection.userName}"),
                    spy.zorkaLog("DEBUG", "SQL", "########################execute ############# ${APPL} ####### ${JK_CORR_RID} ${JK_CORR_RID} ${SQL} ${THIS.class}"),
                    _trace
                        ? spy.subchain(
                            tracer.isInTrace("HTTP") ? null : tracer.begin("SQL", zorka.longCfg("sql.trace.time")),
                            tracer.attr("SQL", "SQL"),
                            __tnt4j.getThread(),
                            tracer.attr("DB", "DB"))
                        : null
            )
            .onError(
                    spy.fetchError("ERR"), 
                    _trace ? tracer.flags(tracer.SUBMIT_TRACE) : null, 
                    sql._error_chain
            )
            .onSubmit(spy.strTime("TIME"), sql._slow_chain, sql._stats_chain)
            .include(

                    // MySQL
                    spy.byMethod("com.mysql.jdbc.PreparedStatement", "execut*"),
                    spy.byMethod("com.mysql.jdbc.JDBC4PreparedStatement", "execut*"),
                    spy.byMethod("com.mysql.jdbc.CallableStatement", "execut*"),
                    spy.byMethod("com.mysql.jdbc.JDBC4CallableStatement", "execut*"),
                    spy.byMethod("com.mysql.jdbc.ServerPreparedStatement", "execut*"),
                    spy.byMethod("com.mysql.jdbc.JDBC4ServerPreparedStatement", "execut*"),

                    // Derby
                    spy.byMethod("org.apache.derby.impl.jdbc.EmbedPreparedStatement", "execut*"),

                    // Oracle
                    spy.byMethod("oracle.jdbc.driver.OracleCallableStatementWrapper", "execut*"),
                    spy.byMethod("oracle.jdbc.driver.OracleStatementWrapper", "execut*"),
                    spy.byMethod("oracle.jdbc.driver.OraclePreparedStatementWrapper", "execut*"),
                    spy.byMethod("oracle.jdbc.driver.OraclePreparedStatement", "~execute[^I].*"),
                    spy.byMethod("oracle.jdbc.driver.OracleStatement", "~execute[^I].*"),
                    spy.byMethod("oracle.jdbc.driver.OracleCallableStatement", "~execute[^I].*")

            )
    );

    if (zorka.boolCfg("tracer")) {
      tracer.exclude("oracle.jdbc.**", "oracle.sql.**");
    } 

    return this;
}

tnt4j_sql = __tnt4j_sql ();